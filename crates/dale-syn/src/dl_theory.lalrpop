use std::str::FromStr;

use dale_util::symbol::Symbol;

use crate::{raw_theory::*, ParserCtx};

grammar(ctx: &mut ParserCtx);

pub File: File = {
    <theories:Theory*> => File { id: ctx.id(), theories }
}

pub Theory: Theory = {
    "\\theory" <name:Ident> "{" <items:Item*> "}" => 
    Theory {id: ctx.id(), name, items}
};

pub Ident: Spanned<Symbol> = {
    <start: @L> <s:r"[a-zA-Z][a-zA-Z0-9_]*"> <end: @R> => Spanned::new(ctx.intern(s), start..end),
    <start: @L> <s:r"_[a-zA-Z0-9]+"> <end: @R> => Spanned::new(ctx.intern(s), start..end),
}

Item: Item = <start: @L> <k:ItemKind> <end: @R> => Item {id: ctx.id(), span: start..end, kind: k};

ItemKind: ItemKind = {
    "\\use" <UseTree> ";" => ItemKind::Use(<>),
    "\\operators" "{" <ops:FunctionDecl*> "}" => ItemKind::Operators(ops),
    "\\sorts" "{" <node:SortDecl*> "}" => ItemKind::Sorts(node),
    "\\datatypes" "{" "}" => ItemKind::DataTypes(DataTypeDecls {}),
    "\\functions" "{" <node:FunctionDecl*> "}" => ItemKind::Functions(node),
    "\\predicates" "{" <node:PredicateDecl*> "}" => ItemKind::Predicates(node),
    "\\axioms" "{" "}" => ItemKind::Axioms(),
    "\\rules" "{" <rules:Rule*> "}" => ItemKind::Rules(rules),
    "\\rulesets" "{" <rs:RuleSetDecl*> "}" => ItemKind::RuleSets(rs)
}

UseTree: UseTree = {
    <start: @L> <prefix:Path> "::*" <end: @R> => UseTree {
        prefix,
        kind: UseTreeKind::Glob,
        span: start..end
    },
    <start: @L> <prefix:Path> <end: @R> => UseTree {
        prefix,
        kind: UseTreeKind::Simple(None),
        span: start..end
    },
    <start: @L> <prefix:Path> "as" <i:Ident> <end: @R> => UseTree {
        prefix,
        kind: UseTreeKind::Simple(Some(i)),
        span: start..end
    },
    <start: @L> <prefix:Path> "::{" <inner_start: @L> <items:Comma<UseTreeWithId>> <inner_end: @R> "}" <end: @R> => UseTree {
        prefix,
        kind: UseTreeKind::Nested {items, span: inner_start..inner_end},
        span: start..end
    }
}

UseTreeWithId: (UseTree, NodeId) = <t:UseTree> => (t, ctx.id());

Separated<T, S>: Vec<T> = {
    <mut v:(<T> <S>)*> <e:T> => {
        v.into_iter().map(|e| e.0).extend_one(e).collect()
    }
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

Semi<T>: Vec<T> = {
    <mut v:(<T> ";")*> <e:T> => {
        v.push(e);
        v
    }
}

DoubleColon<T>: Vec<T> = {
    <mut v:(<T> "::")*> <e:T> => {
        v.push(e);
        v
    }
}

Path: Path = {
    <start: @L> <segments:DoubleColon<PathSegment>> <end: @R> => 
    Path {
        id: ctx.id(),
        span: start..end,
         segments
    }
} 

PathSegment: PathSegment = <start: @L> <ident:Ident> <end: @R> => PathSegment { id: ctx.id(), ident, span: start..end };

FunctionDecl: FunctionDecl = {
    <modifiers:FunctionModifiers> <name:Ident> "->" <sort:Sort> ";" => FunctionDecl {
        id: ctx.id(),
        modifiers,
        name,
        params: vec![],
        where_to_bind: vec![],
        arg_sorts: vec![],
        sort
    },
    <modifiers:FunctionModifiers> <name:Ident> "(" <arg_sorts:Comma<Sort>> ")" "->" <sort:Sort> ";" => FunctionDecl {
        id: ctx.id(),
        modifiers,
        name,
        params: vec![],
        where_to_bind: vec![],
        arg_sorts,
        sort
    },
    <modifiers:FunctionModifiers> <name:Ident> <where_to_bind:WhereToBind> "(" <arg_sorts:Comma<Sort>> ")" "->" <sort:Sort> ";" => FunctionDecl {
        id: ctx.id(),
        modifiers,
        name,
        params: vec![],
        where_to_bind,
        arg_sorts,
        sort
    },
    <modifiers:FunctionModifiers> <name:Ident> "<" <params:Comma<GenericParam>> ">" "->" <sort:Sort> ";" => FunctionDecl {
        id: ctx.id(),
        modifiers,
        name,
        params,
        where_to_bind: vec![],
        arg_sorts: vec![],
        sort
    },
    <modifiers:FunctionModifiers> <name:Ident> "<" <params:Comma<GenericParam>> ">" "(" <arg_sorts:Comma<Sort>> ")" "->" <sort:Sort> ";" => FunctionDecl {
        id: ctx.id(),
        modifiers,
        name,
        params,
        where_to_bind: vec![],
        arg_sorts,
        sort
    },
    <modifiers:FunctionModifiers> <name:Ident> "<" <params:Comma<GenericParam>> ">" <where_to_bind:WhereToBind> "(" <arg_sorts:Comma<Sort>> ")" "->" <sort:Sort> ";" => FunctionDecl {
        id: ctx.id(),
        modifiers,
        name,
        params,
        where_to_bind,
        arg_sorts,
        sort
    }
}

FunctionModifiers: FunctionModifiers = {
    <rigid:"\\rigid"?> <unique:"\\unique"?> <skolem:"\\skolem"?> => FunctionModifiers {
        rigid: rigid.is_some(),
        unique: unique.is_some(),
        skolem: skolem.is_some()
    } 
}

PredicateDecl: PredicateDecl = {
    <rigid:"\\rigid"?> <name:Ident> ";" => PredicateDecl {
        id: ctx.id(),
        rigid: rigid.is_some(),
        name,
        params: vec![],
        where_to_bind: vec![],
        arg_sorts: vec![]
    },
    <rigid:"\\rigid"?> <name:Ident> "(" <arg_sorts:Comma<Sort>> ")" ";" => PredicateDecl {
        id: ctx.id(),
        rigid: rigid.is_some(),
        name,
        params: vec![],
        where_to_bind: vec![],
        arg_sorts
    },
    <rigid:"\\rigid"?> <name:Ident> <where_to_bind:WhereToBind> "(" <arg_sorts:Comma<Sort>> ")" ";" => PredicateDecl {
        id: ctx.id(),
        rigid: rigid.is_some(),
        name,
        params: vec![],
        where_to_bind,
        arg_sorts,
    },
    <rigid:"\\rigid"?> <name:Ident> "<" <params:Comma<GenericParam>> ">" ";" => PredicateDecl {
        id: ctx.id(),
        rigid: rigid.is_some(),
        name,
        params,
        where_to_bind: vec![],
        arg_sorts: vec![],
    },
    <rigid:"\\rigid"?> <name:Ident> "<" <params:Comma<GenericParam>> ">" "(" <arg_sorts:Comma<Sort>> ")" ";" => PredicateDecl {
        id: ctx.id(),
        rigid: rigid.is_some(),
        name,
        params,
        where_to_bind: vec![],
        arg_sorts
    },
    <rigid:"\\rigid"?> <name:Ident> "<" <params:Comma<GenericParam>> ">" <where_to_bind:WhereToBind> "(" <arg_sorts:Comma<Sort>> ")" ";" => PredicateDecl {
        id: ctx.id(),
        rigid: rigid.is_some(),
        name,
        params,
        where_to_bind,
        arg_sorts
    }
}

WhereToBind: Vec<u8> = "{" <nums:Comma<NumU8>> "}" => nums;

NumU8: u8 = <s:r"[0-9]+"> => u8::from_str(s).unwrap();

Sort: Sort = {
    <start: @L> <path:Path> "<" <args:Comma<GenericArg>> ">" <end: @R> => Sort {
        id: ctx.id(),
        span: start..end,
        kind: SortKind::Parametric(path, args)
    },
    <start: @L> <path:Path> <end: @R> => Sort {
        id: ctx.id(),
        span: start..end,
        kind: SortKind::Simple(path)
    },
}

SortDecl: SortDecl = {
    <start: @L> <modifiers:SortModifiers> <name:Ident> "<" <params:Comma<GenericParam>> ">" ";" <end: @R> =>
    SortDecl {
        id: ctx.id(),
        modifiers,
        name,
        span: start..end,
        params,
        extends: None
    },
    <start: @L> <modifiers:SortModifiers> <name:Ident> ";" <end: @R> =>
    SortDecl {
        id: ctx.id(),
        modifiers,
        name,
        span: start..end,
        params: vec![],
        extends: None
    }
}

SortModifiers: SortModifiers = {
    <meta:"\\meta"?> <top:"\\top"?> => SortModifiers {
        top: top.is_some(),
        meta: meta.is_some()
    }
}

GenericParam: GenericParam = {
    <start: @L> "const" <name:Ident> <cstart: @L> ":" <cend: @R> <sort:Sort> <end: @R> => GenericParam {
        name,
        id: ctx.id(),
        colon_span: Some(cstart..cend),
        kind: GenericParamKind::Const {
            sort,
            span: start..end
        },
    },
    <name:Ident> => GenericParam {
        name, 
        id: ctx.id(),
        colon_span: None,
        kind: GenericParamKind::Sort,
    }
}

GenericArg: GenericArg = {
    <start: @L> "const" <t:Term> <end: @R> => GenericArg::Const(t, start..end),
    <Sort> => GenericArg::Sort(<>)
}

Term: Term = {
    <start: @L> <p:Path> "(" <args:Comma<Term>> ")" <end: @R> => Term {
        id: ctx.id(),
        span: start..end,
        kind: TermKind::Call(p, args)
    },
    <start: @L> <p:Path> <end: @R> => Term {
        id: ctx.id(),
        span: start..end,
        kind: TermKind::Path(p)
    }
}

Rule: Rule = {
    <start: @L> <name:Ident> "{" 
        <schema_vars:SchemaVarDecl*> 
        <assumes:Assumes?>
        <find:Find?>
        <goal_specs:GoalSpecs>
        <rule_sets:RuleRuleSets?>
        <display_name:DisplayName?>
    "}" <end: @R> => Rule {
        id: ctx.id(),
        name,
        schema_vars,
        assumes,
        find,
        goal_specs,
        rule_sets,
        display_name,
        span: start..end
    }
}

SchemaVarDecl: SchemaVarDecl = {
    <start: @L> "\\schemaVar" <name:Ident> ":" <sort:Sort> ";" <end: @R> => SchemaVarDecl {
        id: ctx.id(),
        span: start..end,
        name,
        sort
    }
}

Assumes: Spanned<TermOrSeq> = {
    <start: @L> "\\assumes" "(" <tos:TermOrSeq> ")" <end:@R> => Spanned::new(tos, start..end)
}

Find: Spanned<TermOrSeq> = {
    <start: @L> "\\find" "(" <tos:TermOrSeq> ")" <end:@R> => Spanned::new(tos, start..end)
}

GoalSpecs: GoalSpecs = {
    <start: @L> "\\closegoal" <end:@R> => GoalSpecs::CloseGoal(ctx.id(), start..end),
    <start: @L> <specs:Semi<GoalSpec>> <end: @R> => GoalSpecs::Specs(specs, start..end)
}

GoalSpec: GoalSpec = {
    <name:GoalSpecName?> "\\replacewith" "(" <t:TermOrSeq> ")" => GoalSpec {
        id: ctx.id(),
        name,
        replace_with: Some(t),
        add: None
    },
    <name:GoalSpecName?> "\\replacewith" "(" <r:TermOrSeq> ")" "\\add" "(" <a:TermOrSeq> ")" => GoalSpec {
        id: ctx.id(),
        name,
        replace_with: Some(r),
        add: Some(a)
    },
    <name:GoalSpecName?> "\\add" "(" <a:TermOrSeq> ")" => GoalSpec {
        id: ctx.id(),
        name,
        replace_with: None,
        add: Some(a)
    }
}

GoalSpecName: Ident = {
    <start: @L> <s:StringValue> ":" <end: @R> => Spanned::new(ctx.intern(&s), start..end)
}

CloseGoal: Span = <start: @L> "\\closegoal" <end: @R> => start..end;

RuleRuleSets: Spanned<Vec<Path>> = <start: @L> "\\rulesets" "(" <rs:Comma<Path>> ")" <end: @R> => Spanned::new(rs, start..end);

DisplayName: Spanned<String> = <start: @L> "\\displayname" <l:StringValue> <end: @R> => Spanned::new(l, start..end);

TermOrSeq: TermOrSeq = {
    <ante:Comma<Term>> "==>" <succ:Comma<Term>> => TermOrSeq::Seq(Seq { id: ctx.id(), ante, succ }),
    <t:Term> => TermOrSeq::Term(t)
}

RuleSetDecl: RuleSetDecl = <i:Ident> ";" => RuleSetDecl {id: ctx.id(), name: i};

StringValue: String = <l:r#""[^\n"]+""#> => l[1..l.len() - 1].into();