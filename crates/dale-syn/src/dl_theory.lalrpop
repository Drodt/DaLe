use std::str::FromStr;

use dale_util::symbol::Symbol;

use crate::{theory::*, ParserCtx};

grammar(ctx: &mut ParserCtx);

pub File: File = {
    <theories:Theory*> => File { theories }
}

pub Theory: Theory = {
    "\\theory" <name:Ident> "{" <items:Item*> "}" => 
    Theory {name, items}
};

pub Ident: Spanned<Symbol> = {
    <start: @L> <s:r"[a-zA-Z][a-zA-Z0-9_]*"> <end: @R> => Spanned::new(ctx.intern(s), start..end),
    <start: @L> <s:r"_[a-zA-Z0-9]+"> <end: @R> => Spanned::new(ctx.intern(s), start..end),
}

Item: Item = {
    "\\use" <UseTree> ";" => Item::Use(<>),
    <start: @L> "\\operators" "{" <ops:FunctionDecl*> "}" <end: @R> => Item::Operators(
        OperatorDecls {
            span: start..end,
            node: ops
        }
    ),
    <start: @L> "\\sorts" "{" <node:SortDecl*> "}" <end: @R> => Item::Sorts(SortDecls {
        span: start..end,
        node
    }),
    "\\datatypes" "{" "}" => Item::DataTypes(DataTypeDecls {}),
    <start: @L> "\\functions" "{" <node:FunctionDecl*> "}" <end: @R> => Item::Functions(FunctionDecls {
        node,
        span: start..end
    }),
    <start: @L> "\\predicates" "{" <node:PredicateDecl*> "}" <end: @R> => Item::Predicates(PredicateDecls {
        node,
        span: start..end
    }),
    "\\axioms" "{" "}" => Item::Axioms(),
}

UseTree: UseTree = {
    <start: @L> <prefix:Path> "::*" <end: @R> => UseTree {
        prefix,
        kind: UseTreeKind::Glob,
        span: start..end
    },
    <start: @L> <prefix:Path> <end: @R> => UseTree {
        prefix,
        kind: UseTreeKind::Simple(None),
        span: start..end
    },
    <start: @L> <prefix:Path> "as" <i:Ident> <end: @R> => UseTree {
        prefix,
        kind: UseTreeKind::Simple(Some(i)),
        span: start..end
    },
    <start: @L> <prefix:Path> "::{" <inner_start: @L> <items:Comma<UseTree>> <inner_end: @R> "}" <end: @R> => UseTree {
        prefix,
        kind: UseTreeKind::Nested {items, span: inner_start..inner_end},
        span: start..end
    }
}

Separated<T, S>: Vec<T> = {
    <mut v:(<T> <S>)*> <e:T> => {
        v.into_iter().map(|e| e.0).extend_one(e).collect()
    }
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

DoubleColon<T>: Vec<T> = {
    <mut v:(<T> "::")*> <e:T> => {
        v.push(e);
        v
    }
}

Path: Path = {
    <start: @L> <segments:DoubleColon<Ident>> <end: @R> => 
    Path {
        span: start..end, segments
    }
} 

FunctionDecl: FunctionDecl = {
    <modifiers:FunctionModifiers> <name:Ident> "->" <sort:Sort> ";" => FunctionDecl {
        modifiers,
        name,
        params: vec![],
        where_to_bind: vec![],
        arg_sorts: vec![],
        sort
    },
    <modifiers:FunctionModifiers> <name:Ident> "(" <arg_sorts:Comma<Sort>> ")" "->" <sort:Sort> ";" => FunctionDecl {
        modifiers,
        name,
        params: vec![],
        where_to_bind: vec![],
        arg_sorts,
        sort
    },
    <modifiers:FunctionModifiers> <name:Ident> <where_to_bind:WhereToBind> "(" <arg_sorts:Comma<Sort>> ")" "->" <sort:Sort> ";" => FunctionDecl {
        modifiers,
        name,
        params: vec![],
        where_to_bind,
        arg_sorts,
        sort
    },
    <modifiers:FunctionModifiers> <name:Ident> "<" <params:Comma<GenericParam>> ">" "->" <sort:Sort> ";" => FunctionDecl {
        modifiers,
        name,
        params,
        where_to_bind: vec![],
        arg_sorts: vec![],
        sort
    },
    <modifiers:FunctionModifiers> <name:Ident> "<" <params:Comma<GenericParam>> ">" "(" <arg_sorts:Comma<Sort>> ")" "->" <sort:Sort> ";" => FunctionDecl {
        modifiers,
        name,
        params,
        where_to_bind: vec![],
        arg_sorts,
        sort
    },
    <modifiers:FunctionModifiers> <name:Ident> "<" <params:Comma<GenericParam>> ">" <where_to_bind:WhereToBind> "(" <arg_sorts:Comma<Sort>> ")" "->" <sort:Sort> ";" => FunctionDecl {
        modifiers,
        name,
        params,
        where_to_bind,
        arg_sorts,
        sort
    }
}

FunctionModifiers: FunctionModifiers = {
    <rigid:"\\rigid"?> <unique:"\\unique"?> <skolem:"\\skolem"?> => FunctionModifiers {
        rigid: rigid.is_some(),
        unique: unique.is_some(),
        skolem: skolem.is_some()
    } 
}

PredicateDecl: PredicateDecl = {
    <rigid:"\\rigid"?> <name:Ident> ";" => PredicateDecl {
        rigid: rigid.is_some(),
        name,
        params: vec![],
        where_to_bind: vec![],
        arg_sorts: vec![]
    },
    <rigid:"\\rigid"?> <name:Ident> "(" <arg_sorts:Comma<Sort>> ")" ";" => PredicateDecl {
        rigid: rigid.is_some(),
        name,
        params: vec![],
        where_to_bind: vec![],
        arg_sorts
    },
    <rigid:"\\rigid"?> <name:Ident> <where_to_bind:WhereToBind> "(" <arg_sorts:Comma<Sort>> ")" ";" => PredicateDecl {
        rigid: rigid.is_some(),
        name,
        params: vec![],
        where_to_bind,
        arg_sorts,
    },
    <rigid:"\\rigid"?> <name:Ident> "<" <params:Comma<GenericParam>> ">" ";" => PredicateDecl {
        rigid: rigid.is_some(),
        name,
        params,
        where_to_bind: vec![],
        arg_sorts: vec![],
    },
    <rigid:"\\rigid"?> <name:Ident> "<" <params:Comma<GenericParam>> ">" "(" <arg_sorts:Comma<Sort>> ")" ";" => PredicateDecl {
        rigid: rigid.is_some(),
        name,
        params,
        where_to_bind: vec![],
        arg_sorts
    },
    <rigid:"\\rigid"?> <name:Ident> "<" <params:Comma<GenericParam>> ">" <where_to_bind:WhereToBind> "(" <arg_sorts:Comma<Sort>> ")" ";" => PredicateDecl {
        rigid: rigid.is_some(),
        name,
        params,
        where_to_bind,
        arg_sorts
    }
}

WhereToBind: Vec<u8> = "{" <nums:Comma<NumU8>> "}" => nums;

NumU8: u8 = <s:r"[0-9]+"> => u8::from_str(s).unwrap();

Sort: Sort = {
    <start: @L> <name:Ident> "<" <args:Comma<GenericArg>> ">" <end: @R> => Sort {
        span: start..end,
        kind: SortKind::Parametric(name, args)
    },
    <start: @L> <name:Ident> <end: @R> => Sort {
        span: start..end,
        kind: SortKind::Simple(name)
    },
}

SortDecl: SortDecl = {
    <start: @L> <modifiers:SortModifiers> <name:Ident> "<" <params:Comma<GenericParam>> ">" ";" <end: @R> =>
    SortDecl {
        modifiers,
        name,
        span: start..end,
        params,
        extends: None
    },
    <start: @L> <modifiers:SortModifiers> <name:Ident> ";" <end: @R> =>
    SortDecl {
        modifiers,
        name,
        span: start..end,
        params: vec![],
        extends: None
    }
}

SortModifiers: SortModifiers = {
    <meta:"\\meta"?> <top:"\\top"?> => SortModifiers {
        top: top.is_some(),
        meta: meta.is_some()
    }
}

GenericParam: GenericParam = {
    <start: @L> "const" <name:Ident> <cstart: @L> ":" <cend: @R> <sort:Sort> <end: @R> => GenericParam {
        name,
        colon_span: Some(cstart..cend),
        kind: GenericParamKind::Const {
            sort,
            span: start..end
        },
    },
    <name:Ident> => GenericParam {
        name,
        colon_span: None,
        kind: GenericParamKind::Sort,
    }
}

GenericArg: GenericArg = {
    <start: @L> "const" <t:Term> <end: @R> => GenericArg::Const(t, start..end),
    <Sort> => GenericArg::Sort(<>)
}

Term: Term = {
    <start: @L> <p:Path> <end: @R> => Term {
        span: start..end,
        kind: TermKind::Path(p)
    }
}