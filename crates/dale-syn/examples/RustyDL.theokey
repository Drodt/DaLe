\theory Prop {
  \sorts {
    \top Any;
    \meta Formula; 
  }

  \operators {
    \rigid true -> Formula;
    \rigid false -> Formula;
    \rigid not(Formula) -> Formula;
    \rigid and(Formula, Formula) -> Formula;
    \rigid or(Formula, Formula) -> Formula;
    \rigid imp(Formula, Formula) -> Formula;
    \rigid equiv(Formula, Formula) -> Formula;
  }

  \rulesets {
    closure;
    replace_known_left;
    replace_known_right;
    concrete;
    alpha;
    beta;
    cut;
    cut_direct;
  }

  \rules {
    close {
      \schemaVar b: Formula;
      \assumes(b ==>)
      \find(==> b)
      \closegoal
      \rulesets(closure)
      \displayname "close"
    }

    closeAntec {
      \schemaVar b: Formula;
      \assumes( ==> b)
      \find(b ==>)
      \closegoal
      \displayname "close"
    }

    closeFalse {
      \find(false ==>)
      \closegoal
      \rulesets(closure)
    }

    closeTrue {
      \find( ==> true)
      \closegoal 
      \rulesets(closure)
    }

    replace_known_left {
      \schemaVar b: Formula;
      \assumes(b ==>)
      \find(b)
      \replacewith(true)
      \rulesets(replace_known_left)
    }

    replace_known_right {
      \schemaVar b: Formula;
      \assumes( ==> b)
      \find(b)
      \replacewith(false)
      \rulesets(replace_known_right)
    }

    true_left {
      \find(true ==>)
      \replacewith( ==>)
      \rulesets(concrete)
    }

    false_right {
      \find( ==> false)
      \replacewith( ==>)
      \rulesets(concrete)
    }
    
    notLeft {
      \schemaVar b: Formula;
      \find(not(b) ==>)
      \replacewith( ==> b)
      \rulesets(alpha)
    }

    notRight {
      \schemaVar b: Formula;
      \find( ==> not(b))
      \replacewith(b ==>)
      \rulesets(alpha)
    }

    impLeft {
      \schemaVar b: Formula;
      \schemaVar c: Formula;
      \find(imp(b, c) ==>)
      \replacewith(==> b);
      \replacewith(c ==>)
      \rulesets(beta)
    }

    doubleImpLeft {
      \schemaVar b: Formula;
      \schemaVar c: Formula;
      \schemaVar d: Formula;
      \find(imp(imp(b, c), d) ==>)
      \replacewith( ==> b);
      \replacewith( ==> c);
      \replacewith(d ==>)
      \rulesets(beta)
    }

    impRight {
      \schemaVar b: Formula;
      \schemaVar c: Formula;
      \find( ==> imp(b, c))
      \replacewith(b ==> c)
      \rulesets(alpha)
    }

    andLeft {
      \schemaVar b: Formula;
      \schemaVar c: Formula;
      \find(and(b, c) ==>)
      \replacewith(b, c ==>) \rulesets(alpha)
    }
    andRight {
      \schemaVar b: Formula;
      \schemaVar c: Formula;
      \find( ==> and(b, c))
      \replacewith( ==> b);
      \replacewith( ==> c)
      \rulesets(beta)
    }
    orLeft {
      \schemaVar b: Formula;
      \schemaVar c: Formula;
      \find(or(b, c) ==>)
      "#b":
        \replacewith(b ==>);
      "#c":
        \replacewith(c ==>)
      \rulesets(beta)
    }
    orRight {
      \schemaVar b: Formula;
      \schemaVar c: Formula;
      \find( ==> or(b, c))
      \replacewith( ==> b, c) \rulesets(alpha)
    }

    equiv_left {
      \schemaVar b: Formula;
      \schemaVar c: Formula;
      \find(equiv(b, c) ==>)
      \replacewith(b, c ==>);
      \replacewith( ==> b, c)
      \rulesets(beta)
    }

    equiv_right {
      \schemaVar b: Formula;
      \schemaVar c: Formula;
      \find( ==> equiv(b, c))
      "Case '->'":
        \replacewith(b ==> c);
      "Case '<-'":
        \replacewith(c ==> b)
      \rulesets(beta)
    }

    split_or_strong {
      \schemaVar b: Formula;
      \schemaVar c: Formula;
      \find(or(b, c) ==>)
      \replacewith(b ==>);
      \replacewith(c ==> b)
    }
    rotate_and {
      \schemaVar b: Formula;
      \schemaVar c: Formula;
      \schemaVar d: Formula;
      \find(and(b, and(c, d)))
      \replacewith(and(c, and(b, d)))
    }
    rotate_or {
      \schemaVar b: Formula;
      \schemaVar c: Formula;
      \schemaVar d: Formula;
      \find(or(b, or(c, d)))
      \replacewith(or(c, or(b, d)))
    }

    double_not {
      \schemaVar b: Formula;
      \find(not(not(b)))
      \replacewith(b)
      \rulesets(concrete)
    }

    concrete_not_1 {
      \find(not(true))
      \replacewith(false)
      \rulesets(concrete)
    }
    concrete_not_2 {
      \find(not(false))
      \replacewith(true) 
      \rulesets(concrete)
    }

    concrete_impl_1 {
      \schemaVar b: Formula;
      \find(imp(true, b))
      \replacewith(b)
      \rulesets(concrete)
    }
    concrete_impl_2 {
      \schemaVar b: Formula;
      \find(imp(false, b))
      \replacewith(true)
      \rulesets(concrete)
    }
    concrete_impl_3 {
      \schemaVar b: Formula;
      \find(imp(b, false))
      \replacewith(not(b))
      \rulesets(concrete)
    }
    concrete_impl_4 {
      \schemaVar b: Formula;
      \find(imp(b, true))
      \replacewith(true)
      \rulesets(concrete)
    }

    concrete_and_1 {
      \schemaVar b: Formula;
      \find(and(true, b))
      \replacewith(b)
      \rulesets(concrete)
    }
    concrete_and_2 {
      \schemaVar b: Formula;
      \find(and(false, b))
      \replacewith(false)
      \rulesets(concrete)
    }
    concrete_and_3 {
      \schemaVar b: Formula;
      \find(and(b, true))
      \replacewith(b)
      \rulesets(concrete)
    }
    concrete_and_4 {
      \schemaVar b: Formula;
      \find(and(b, false))
      \replacewith(false)
      \rulesets(concrete)
    }

    concrete_or_1 {
      \schemaVar b: Formula;
      \find(or(true, b))
      \replacewith(true)
      \rulesets(concrete)
    }
    concrete_or_2 {
      \schemaVar b: Formula;
      \find(or(false, b))
      \replacewith(b)
      \rulesets(concrete)
    }
    concrete_or_3 {
      \schemaVar b: Formula;
      \find(or(b, true))
      \replacewith(true)
      \rulesets(concrete)
    }
    concrete_or_4 {
      \schemaVar b: Formula;
      \find(or(b, false))
      \replacewith(b) 
      \rulesets(concrete)
    }

    concrete_or_5 {
      \schemaVar b: Formula;
      \schemaVar c: Formula;
      \find(or(and(c, b), and(c, not(b))))
      \replacewith(c)
      \rulesets(concrete)
      \displayname "distr_elim"
    }

    concrete_eq_1 {
      \schemaVar b: Formula;
      \find(equiv(true, b))
      \replacewith(b)
      \rulesets(concrete)
    }
    concrete_eq_2 {
      \schemaVar b: Formula;
      \find(equiv(false, b))
      \replacewith(not(b))
      \rulesets(concrete)
    }
    concrete_eq_3 {
      \schemaVar b: Formula;
      \find(equiv(b, true))
      \replacewith(b) 
      \rulesets(concrete)
    }
    concrete_eq_4 {
      \schemaVar b: Formula;
      \find(equiv(b, false))
      \replacewith(not(b))
      \rulesets(concrete)
    }

    cut {
      \schemaVar cutFormula: Formula;
      "CUT: #cutFormula TRUE":
        \add(cutFormula ==>);
      "CUT: #cutFormula FALSE":
        \add( ==> cutFormula)
      \rulesets(cut)
    }

    cut_direct {
      \schemaVar cutFormula: Formula;
      \find(cutFormula)
      "CUT: #cutFormula TRUE":
        \replacewith(true)
        \add(cutFormula ==>);
      "CUT: #cutFormula FALSE":
        \replacewith(false)
        \add( ==> cutFormula)
      \rulesets(cut_direct)
    }

    cut_direct_r {
      \schemaVar b: Formula;
      \find( ==> b)
      \replacewith( ==> b);
      \add(b ==>)
    }
    cut_direct_l {
      \schemaVar b: Formula;
      \find(b ==>)
      \replacewith(b ==>);
      \add( ==> b)
    }
  }
}

\theory FOL {
  \use Prop::*;

  \sorts {
    \meta NUMBER;
  }

  \operators {
    \rigid all<S>{0}(Formula) -> Formula;
    \rigid exists<S>{0}(Formula) -> Formula;
    \rigid var<S>(NUMBER) -> S;
    \rigid subst<S>(S) -> S;
  }

  \predicates {
    \rigid eq(Any, Any);
  }
}

\theory IfThenElse {
  \use Prop::*;
  
  \operators {
    \rigid ifThenElse<S>(Formula, S, S) -> S;
  }
}

\theory Bool {
  \sorts {
    bool;
  }

  \functions {
    \rigid TRUE -> bool;
    \rigid FALSE -> bool;
  }
}

\theory Int {
  \sorts {
    numbers;
    int;
  }

  \functions {
    \rigid num -> numbers;
    \rigid _0(numbers) -> numbers;
    \rigid _1(numbers) -> numbers;
    \rigid _2(numbers) -> numbers;
    \rigid _3(numbers) -> numbers;
    \rigid _4(numbers) -> numbers;
    \rigid _5(numbers) -> numbers;
    \rigid _6(numbers) -> numbers;
    \rigid _7(numbers) -> numbers;
    \rigid _8(numbers) -> numbers;
    \rigid _9(numbers) -> numbers;
    \rigid negLit(numbers) -> numbers;
    
    \rigid Z(numbers) -> int;

    \rigid neg(int) -> int;
    \rigid add(int, int) -> int;
    \rigid sub(int, int) -> int;
    \rigid mul(int, int) -> int;
    \rigid div(int, int) -> int;
    \rigid mod(int, int) -> int;
    \rigid pow(int, int) -> int;
    \rigid log(int, int) -> int;
  }

  \predicates {
    \rigid leq(int, int);
    \rigid lt(int, int);
    \rigid geq(int, int);
    \rigid gt(int, int);
  }
}

\theory RFOL {
  \use FOL::*;
  \use Bool::*;
  \use IfThenElse::*;
  \use Int::*;

  \sorts {
    never;
    char;

    Array<E, const N: int>;
    Field<S>;

    SRef<S>;
    MRef<S>;
    Place<S>;
  }

  \functions {
    rdiv(int, int) -> int;

    u8_MIN -> int;
    u8_MAX -> int;
    u16_MIN -> int;
    u16_MAX -> int;
    u32_MIN -> int;
    u32_MAX -> int;
    u64_MIN -> int;
    u64_MAX -> int;
    u128_MIN -> int;
    u128_MAX -> int;
    usize_MIN -> int;
    usize_MAX -> int;
    i8_MIN -> int;
    i8_MAX -> int;
    i16_MIN -> int;
    i16_MAX -> int;
    i32_MIN -> int;
    i32_MAX -> int;
    i64_MIN -> int;
    i64_MAX -> int;
    i128_MIN -> int;
    i128_MAX -> int;
    isize_MIN -> int;
    isize_MAX -> int;

    len<E, const N: int>(Array<E, const N>) -> int;
    arr_repeat<E, const N: int>(E) -> Array<E, const N>;
    arr_outside<E> -> E;
    arr_get<E, const N: int>(Array<E, const N>, int) -> E;
    arr_set<E, const N: int>(Array<E, const N>, int, E) -> Array<E, const N>;

    refS<S>(S) -> SRef<S>;
    refM<S>(Place<S>) -> MRef<S>;
    derefS<S>(SRef<S>) -> S;
    derefM<S>(MRef<S>) -> S;
  }

  \predicates {
    in_u8(int);
    in_u16(int);
    in_u32(int);
    in_u64(int);
    in_u128(int);
    in_usize(int);
    in_i8(int);
    in_i16(int);
    in_i32(int);
    in_i64(int);
    in_i128(int);
    in_isize(int);
  }
}