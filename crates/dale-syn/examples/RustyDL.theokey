\theory Prop {
  \sorts {
    \top Any;
    \meta Formula; 
  }

  \operators {
    \rigid true -> Formula;
    \rigid false -> Formula;
    \rigid not(Formula) -> Formula;
    \rigid and(Formula, Formula) -> Formula;
    \rigid or(Formula, Formula) -> Formula;
    \rigid imp(Formula, Formula) -> Formula;
    \rigid equiv(Formula, Formula) -> Formula;
  }
}

\theory FOL {
  \use Prop::*;

  \operators {
    \rigid all<S>{0}(Formula) -> Formula;
    \rigid exists<S>{0}(Formula) -> Formula;
    \rigid var<S>(NUMBER) -> S;
    \rigid subst<S>(S) -> S;
  }

  \predicates {
    \rigid eq(Any, Any);
  }
}

\theory IfThenElse {
  \operators {
    \rigid ifThenElse<S>(Formula, S, S) -> S;
  }
}

\theory Bool {
  \sorts {
    bool;
  }

  \functions {
    \rigid TRUE -> bool;
    \rigid FALSE -> bool;
  }
}

\theory Int {
  \sorts {
    numbers;
    int;
  }

  \functions {
    \rigid num -> numbers;
    \rigid _0(numbers) -> numbers;
    \rigid _1(numbers) -> numbers;
    \rigid _2(numbers) -> numbers;
    \rigid _3(numbers) -> numbers;
    \rigid _4(numbers) -> numbers;
    \rigid _5(numbers) -> numbers;
    \rigid _6(numbers) -> numbers;
    \rigid _7(numbers) -> numbers;
    \rigid _8(numbers) -> numbers;
    \rigid _9(numbers) -> numbers;
    \rigid negLit(numbers) -> numbers;
    
    \rigid Z(numbers) -> int;

    \rigid neg(int) -> int;
    \rigid add(int, int) -> int;
    \rigid sub(int, int) -> int;
    \rigid mul(int, int) -> int;
    \rigid div(int, int) -> int;
    \rigid mod(int, int) -> int;
    \rigid pow(int, int) -> int;
    \rigid log(int, int) -> int;
  }

  \predicates {
    \rigid leq(int, int);
    \rigid lt(int, int);
    \rigid geq(int, int);
    \rigid gt(int, int);
  }
}

\theory RFOL {
  \use FOL::*;
  \use Bool::*;
  \use IfThenElse::*;
  \use Int::*;

  \sorts {
    never;
    char;

    Array<E, const N: int>;
    Field<S>;

    SRef<S>;
    MRef<S>;
    Place<S>;
  }

  \functions {
    rdiv(int, int) -> int;

    u8_MIN -> int;
    u8_MAX -> int;
    u16_MIN -> int;
    u16_MAX -> int;
    u32_MIN -> int;
    u32_MAX -> int;
    u64_MIN -> int;
    u64_MAX -> int;
    u128_MIN -> int;
    u128_MAX -> int;
    usize_MIN -> int;
    usize_MAX -> int;
    i8_MIN -> int;
    i8_MAX -> int;
    i16_MIN -> int;
    i16_MAX -> int;
    i32_MIN -> int;
    i32_MAX -> int;
    i64_MIN -> int;
    i64_MAX -> int;
    i128_MIN -> int;
    i128_MAX -> int;
    isize_MIN -> int;
    isize_MAX -> int;

    len<E, const N: int>(Array<E, const N>) -> int;
    arr_repeat<E, const N: int>(E) -> Array<E, const N>;
    arr_outside<E> -> E;
    arr_get<E, const N: int>(Array<E, const N>, int) -> E;
    arr_set<E, const N: int>(Array<E, const N>, int, E) -> Array<E, const N>;

    refS<S>(S) -> SRef<S>;
    refM<S>(Place<S>) -> MRef<S>;
    derefS<S>(SRef<S>) -> S;
    derefM<S>(MRef<S>) -> S;
  }

  \predicates {
    in_u8(int);
    in_u16(int);
    in_u32(int);
    in_u64(int);
    in_u128(int);
    in_usize(int);
    in_i8(int);
    in_i16(int);
    in_i32(int);
    in_i64(int);
    in_i128(int);
    in_isize(int);
  }
}